### 模块规范

* CommonJS

  * require/module.exports
  * 服务器端的解决方案, 同步引入模块

它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

  * 所有代码都运行在模块作用域，不会污染全局作用域
  * 模块是同步加载的，即只有加载完成，才能执行后面的操作
  * 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存
  * require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值

* AMD 方案

这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

* CMD 方案

这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。

* ES6 

使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同

* ES6 模块与 CommonJS 的差异。

  * 导入导出语法不同，commonjs是module.exports和require;es6是export和import
  * commonjs是“运行时加载”模块：CommonJS 模块就是对象，运行时才能确定模块的值
  * es6是“编译时加载”或“静态加载”模块：ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入
  * 在 rollup、 webpack 等构建工具中常见的 Tree Shaking 能力，就是依赖于 ES6 模块的静态特性实现的。
  * es6会提升import到顶部
  * commonjs导出的是一个值拷贝，会对加载结果缓存，一旦内部再修改这个值，不会同步到外部。ES6导出一个引用，内部修改可以同步到外部
