### diff算法

* 虚拟dom
  * 为什么需要
  Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化
  但是，dom操作慢：
    * js代码调用DOM的接口，这就相当于两个互相独立的模块发生交互，这样的性能损耗是非常高的。
    * 然后影响DOM操作性能的主要原因是它会导致浏览器重绘和重排。
  ==》通过js内存中的数据结构来模拟dom，通过一定的算法找出最小dom操作，这样就可以提高dom操作的性能

  * 结构：
  tag
  data
  children
  text
  elm
  key

对两个虚拟dom对象进行diff，如果
* （1）简单情况，patch(oldVnode,vnode)
  * 旧Vdom不存在，直接根据新dom创建新的dom
  * 新Vdom不存在，销毁老节点
  * 根据特殊值：标签名，是否存在属性，key，input还有type判断是否属于相同/可复用标签
    * 不是相同节点，直接创建新dom
    * 相同节点diff: patchVnode

* （2）单节点精细对比：patchVnode(oldVnode,vnode)
    * 新旧Vdom指向相同或静态节点(v-once)&&key相同，则不需要更新
    * children比较：
      * 非复杂情况：并不是都有children
      * 复杂情况：都有children，需要遍历children进行diff

* （3）复杂情况，对比children：updateChildren
  * 特殊的遍历方式（双端比较的算法）：头头，尾尾，头尾，尾头依次对比是否为相同标签
    * 相同，则递归调用节点精细对比方法，同时索引变化，如果是头尾，尾头相同，则对原生进行dom操作进行位置移动
    * 不同，继续遍历，直到四种方式对比完毕，然后通过key值在旧的Vdom中查找，如果找到，则移动节点位置，否则创建新节点

### vue3优化
* 添加静态标记：Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff
在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag，在这个基础上再进行核心的diff算法
* 静态提升：创建静态节点时保存，后续直接复用
* 事件缓存：将事件缓存，可以理解为变成静态的了
* 算法优化
  * 同步头部节点
  * 同步尾部节点
  * 仅有节点新增，新增
  * 仅有节点移除，删除
  * 通过最长递增子序列算法，找出如何移动元素，移动的次数最少

### react
* 和vue相同点
  * 同级比较，如果一个DOM节点在前后两次更新中跨越了层级，那么不会尝试复用他。
  * 在遍历中都会通过标签类型，key等判断是否为可复用的节点。