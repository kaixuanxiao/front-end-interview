### 内存泄漏

* 垃圾清除机制

* 内存泄漏场景

#### 标记清除

现在所有的浏览器使用的垃圾收集方式是标记清除。这种算法把变量是否被引用简化为，变量是否可获得。

从根（在JavaScript中为全局对象）开始找引用变量，及这些变量引用的变量，这样一直找下去。能找到的变量为可获得变量。

这种算法的思想是给当前不使用的值加上标记，然后再回收其内存

算法流程：

　　1.浏览器再运行的时候会给存储再内存中的所有变量都加上标记

　　2.去掉环境中的变量以及被环境中引用的变量的标记

　　3.如果还有变量有标记，就会被视为准备删除的变量

　  4.垃圾回收机制完成内存的清除工作，销毁那些带标记的变量，并回收他们所占

#### 内存泄漏场景

第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。由于闭包会携带包含它的函数的作用域，因此会占用更多的内存，过度的使用闭包会导致内存占用过多。使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。

```js
function assignHandler() { 
 let element = document.getElementById('someElement'); 
 element.onclick = () => console.log(element.id); 
} 

// 优化
function assignHandler() { 
 let element = document.getElementById('someElement'); 
 let id = element.id; 
 element.onclick = () => console.log(id);
 element = null; 
} 
```